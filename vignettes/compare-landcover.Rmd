---
title: "Calculating cropland biases"
author: "Lyndon Estes"
date: "01 October 2014"
output:
  html_document:
    highlight: tango
    theme: spacelab
    toc: yes
---

## Overview
This section of the analysis calculates the differences between the GTI cropland percentages and those from the various landcover products. It draws from results generated by the [cropland pre-processing](https://github.com/PrincetonUniversity/SAcropland/blob/master/vignettes/sa-cropland-analysis.Rmd). (Note to self here: I want to have a transportable link between chapters here, rather than a direct link to the other RMD document in 
github).

## Analyses
### Load in data 
1. Set up paths
```{r, eval = FALSE}
library(lmisc)
library(raster)
library(SAcropland)
p_root <- proj_root("SAcropland")
p_data <- full_path(p_root, "SAcropland/external/ext_data/")
```

2. Load cropland grids 
  + Derived from global landcover products

```{r, eval = FALSE}
salc <- raster(full_path(p_data, "sa_ag_masked.tif")) * 100
globsa_list_sum <- lapply(full_path(p_data, dir(p_data, "globSA*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
modsa_list_sum <- lapply(full_path(p_data, dir(p_data, "mod_1*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
glcsa <- raster(full_path(p_data, "glcsa_masked.tif"))
geow <- raster(full_path(p_data, "geowikisa_masked.tif"))
lclist <- c(salc, globsa_list_sum, modsa_list_sum, glcsa, geow)  # into list
names(lclist) <- c("sa30", "globmin", "globmu", "globmax", "modmin", "modmu", "modmax", "glcsh", "geow")
```

  + SA landcover data
```{r, eval = FALSE}
load(full_path(p_data, "MZshapes.Rdata"))  
paths <- full_path(p_data, dir(p_data, paste("cover*.*sum_mask*", sep = "")))
gti <- lapply(paths, raster)
names(gti) <- c("g2007", "g2011")
```
[[back to top]][Overview]

### Calculate differences at different levels of aggregation
This steps draws on functions I wrote to calculate the actual and absolute differences between a given "master" grid and lists of other grids. This comparison is done at multiple aggregations, ranging from 1-600 km resolution cropland averages. The lists have two levels of nesting, here the upper provides the resolution, the inner provides the different landcover datasets. 

```{r, eval = FALSE}
# Aggregate rasters
fact <- c(5, 10, 20, 50, 100, 200, 300)
lc_agg <- aggregate_rast_list(fact, lclist)   # landcover rasters 
gti_agg <- aggregate_rast_list(fact, gti)  # GTI rasters

# Calculate differences
dlist_act <- rast_list_math(list(names(lclist), names(lc_agg), names(gti)), gti_agg, lc_agg, "a - b", 
                            silent = FALSE)  # actual
dlist_abs <- rast_list_math(list(names(lclist), names(lc_agg), names(gti)), gti_agg, lc_agg, "abs(a - b)", 
                            silent = FALSE)  # absolute
dlist_gti <- rast_list_math(list("g2007", names(gti_agg), "g2011"), gti_agg, gti_agg, "a - b", silent = FALSE)

save(dlist_act, file = full_path(p_data, "d_grid_act.rda"))
save(dlist_abs, file = full_path(p_data, "d_grid_abs.rda"))
# load(full_path(p_data, "d_grid_act.rda"))
# load(full_path(p_data, "d_grid_abs.rda"))

```
[[back to top]][Overview]
### Bias as function of cropcover
+ First create NA mask at 1 km resolution, then weighting raster based on number of non-NA cells in each aggregated pixel, and then "bin" rasters, where each category represents a different cropland fractional cover range (0-5%, 5-10%, etc) 
```{r, eval = FALSE}
# NA mask and weights
namask <- !is.na(gti[[1]])  
area_wgts <- aggregate_rast_list(fact, list(namask), fun = sum)
namask[namask == 0] <- NA

# cropland cover bins
binv <- seq(0, 100, 5)
gti_bins <- lapply(gti_agg, function(x) lapply(x, function(y) cut(y, breaks = binv, include.lowest = TRUE)))
```

+ Calculate biases, pooling MODIS and GlobCover across all version
Step 1. Reshape lists, so that all MODIS and GlobCover variants are pooled by scale
```{r, eval = FALSE}
# Set up indexing parameters
fact_all <- c(1, fact)# full aggregation levels
lev_vec <- paste("f", fact_all, sep = "") 
nm_rt <- c("sa30", "glob", "mod", "glcsh", "geow")

# Reshape the list of actual landcover differences
dlists <- lapply(list(dlist_act, dlist_abs), function(i) {
  resh <- lapply(nm_rt, function(x) {  # select sensor
    l2 <- lapply(lev_vec, function(y) {  # isolate by scale
      l3 <- lapply(i[grep(x, names(i))], function(z) z[[y]])  # sensor by scale
      named_out(l3, names(i)[grep(x, names(i))])
      })
    named_out(l2, lev_vec)
  })
  named_out(resh, nm_rt)
})
names(dlists) <- c("act", "abs")
rm(dlist_act, dlist_abs)  # remove original to make space
```

+ Then calculate biases across datasets
```{r, eval = FALSE}
dang <- Sys.time()
dstats_all <- lapply(dlists, function(i) {
  #i <- dlists[[1]]
  print("processing 1 of 2 main bias lists")
  dstats <- lapply(names(i), function(x) {
    #x <- names(i)[1]
    print(paste("..", x))
    l1 <- lapply(lev_vec, function(y) {
      #y <- lev_vec[1]
      print(paste("....", y))
      d1 <- do.call(rbind, lapply(1:(length(binv) - 1), function(j) {
        #j <- 1
        print(paste("......bin", j))
        d2 <- do.call(rbind, lapply(1:length(i[[x]][[y]]), function(z) {
          print(paste("........variant", z))
          #z <- 1
          l3 <- i[[x]][[y]][[z]]
          d3 <- do.call(rbind, lapply(1:length(l3), function(k) {
            #print(paste("..........gti set", k))
            #cbind(k, k, k)
            rs <- gti_bins[[y]][[k]] == j    
            rs[rs == 0] <- NA
            o <- rs * l3[[k]]
            w <- area_wgts[[y]][[1]] * rs
            oo <- cbind.data.frame("lc" = rep(names(i)[z], length(w)), getValues(o), getValues(w))
          }))
          d3f <- d3[!is.na(d3[, 2]), ]
        }))
        if(nrow(d2) > (length(i[[x]][[y]]) * 10)) {
        qs <- c(nrow(d2), box_stats(d2[, 2], weighted = TRUE, weight.opts = list("weights" = d2[, 3])))
        } else if((nrow(d2) > 0) & (nrow(d2) < length(i[[x]][[y]]) * 20)) {
          qs <- c(rep(NA, 6), Hmisc::wtd.mean(d2[, 2], weights = d2[, 3], na.rm = FALSE))
        } else {
          qs <- rep(NA, 7)
        }
      }))
      cbind(binv[-1], d1)
      })
    named_out(l1, lev_vec)
  })
  named_out(dstats, names(i))
})
dut <- Sys.time() - dang  # 33 minutes

save(dstats_all, file = full_path(p_data, "bias_stats.rda"))

rl <- lapply(gti_agg$f20, function(x) cut(x, breaks = binv, include.lowest = TRUE))
r3l <- dlists$act$geow$f20$geow

t2 <- do.call(rbind, lapply(1:(length(binv) - 1), function(x) {
  print(x)
  l1 <- do.call(rbind, lapply(1:length(rl), function(k) {
    rs <- rl[[k]] == x
    rs[rs == 0] <- NA
    o <- rs * r3l[[k]]
    w <- area_wgts$f20[[1]] * rs
    oo <- cbind(getValues(o), getValues(w))
  }))
  l12 <- l1[!is.na(l1[, 1]), ]
  if(nrow(l12) > 0) {
    qs <- c(nrow(l12), box_stats(x = l12[, 1], weighted = TRUE, weight.opts = list("weights" = l12[, 2])))
  } else {
    qs <- rep(NA, 7)
  }
  qs
}))
#t2[, -1] - dstats_all$act$geow$f20[, -c(1:2)]

```

Checks: compared number of non-NA cells coming out of each GTI version at each level of aggregation (fine); compared cell counts between previous committed version and this one (difference exists, but due to fact that gtimu is no longer considered; checked that previous versions of difference rasters and reshapes of them were referencing the correct GTI-landcover bias rasters (i.e. to make sure rasters weren't incorrectly indexed: all fine)); box_stats with weighted quantile option compared to previous commit where wtd.quantile was used separately (fine). 

### Bias as function of cropcover
Values from the bias rasters calculated in the previous section are binned by percent cropland cover.  There are a couple of tricky aspects here, related to choosing which cropland map provides the bins. The 2011 GTI mapset more closely corresponds to the MODIS and GLC-SHARE datasets in time, whereas GlobCover and the SA landcover dataset fall closer to or are between the 2007 mapset. __Wayforward__: Calculate whether there is any bias between the 2007 and 2011 cropland estimates by GTI. And also see how much difference exists in bias estimates _as a function of cropcover_ when 2011 GTI provides the bin estimates, and the difference rasters are calculated against different GTI datasets (2007, the mean of 2007 and 2011, and 2011). 

Another complication is the landcover classes to include in the GTI data.  Originally I had the subsistence class added in, but I am now only going to use the no-subsistence set. The no-subsistence set masks out all pixels with >0% subsistence farming coverage. I have also masked out all areas having forestry plantations, which are included in the GLC-SHARE dataset.  

```{r, eval = FALSE}
binv <- seq(0, 100, 5)  # cropland bins

# GTI versus GTI (to measure difference in the different permutations of GTI)
extract_bin_values(gti_agg, "gti2011", diff_list_gti, binv, full_path(p_data, "gti_diff_bin")) 

# Actual landcover differences relative to GTI
nmrt <- c("2007_bin", "2011_bin", "mu_bin")
mind <- c("gti2007", "gti2011", "gtimu")
dind <- c("d2007", "d2011", "dmu")
onm <- paste("act", nmrt, sep = "_")
lapply(1:3, function(x) {
  extract_bin_values(gti_agg, mind[x], diff_list_act[[dind[x]]], binv, full_path(p_data, onm[x]))
})

# Absolute landcover differences
onm <- paste("abs", nmrt, sep = "_")# c("abs_2011_ns_bin", "abs_mu_ns_bin", "abs_2007_ns_bin")
lapply(1:3, function(x) {
  extract_bin_values(gti_agg, mind[x], diff_list_abs[[dind[x]]], binv, full_path(p_data, onm[x]))
})
rm(diff_list_abs, diff_list_act, diff_list_gti)
```
[[back to top]][Overview]

### Calculate biases
#### For GTI data
```{r, eval = FALSE}
load(full_path(p_data, "gti_diff_bin.rda"))
gti_bias <- bin_stats(bin_val_list, fun.list = list(mean), binv)
```

#### For difference rasters
For this, we will have to reshape the difference lists so that we end up with a list that pools biases by cropcover bin across the 3 GTI permutations, but separately for each scale and sensor, before calculating statistics. This is to account for as much uncertainty as possible (e.g. for temporal mismatches between landcover products and GTI). MODIS and GlobCover sets also need to be pooled across the high, medium, and low cover estimates.  
```{r, eval = FALSE}
# Read in and reshape actual differences
nms <- full_path(p_data, paste(paste("act", nmrt, sep = "_"), ".rda", sep = ""))
bin_act <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_act) <- paste("act", nmrt, sep = "_")

fact_all <- c(1, fact)# full aggregation levels
lev_vec <- paste("f", fact_all, sep = "")  
resh <- reshape_diff_list(bin_act, names(lclist), lev_vec, length(binv) - 1)  # reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_act <- c(resh[c("sa30", "glcsh", "geow")], resh_modglob)  # Recombine final reshapes into output list
rm(bin_act)

# Reshape absolute differences
nms <- full_path(p_data, paste(paste("abs", nmrt, sep = "_"), ".rda", sep = ""))
bin_abs <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_abs) <- paste("bs", nmrt, sep = "_")

resh <- reshape_diff_list(bin_abs, names(lclist), lev_vec, length(binv) - 1)  # Reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_abs <- c(resh[c("sa30", "glcsh", "geow")], resh_modglob)  # Recombine final reshapes into output list
rm(resh, resh_modglob, bin_abs)

```

A note: I did checks here to make sure the reshaping was correct, namely by manually pulling out a particular bin from a particular sensor and scale and calculating the mean from that and comparing to the mean from the corresponding part of the reshaped lists. This includes checking the pooled MODIS datasets. 
[[back to top]][Overview]

### Calculate statistics
Now to calculate final statistics per landcover "density" bin (mean, median, 5th, 25th, 75th and 95th percentiles, etc) for each landcover set at each level of aggregation. I am relying on the box_stats function from my lmisc package to generate the necessary statistics for this.

```{r, eval = FALSE}
act_stats <- lapply(resh_out_act, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
abs_stats <- lapply(resh_out_abs, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
```

Save bias statistics and clean up transitional files
```{r, eval = FALSE}
save(gti_bias, act_stats, abs_stats, file = full_path(p_data, "bias_stats.rda"))
for(i in c("act", "abs")) file.remove(full_path(p_data, paste(paste(i, nmrt, sep = "_"), ".rda", sep = "")))
```

## Next steps
Plot bias results.  

[[back to top]][Overview]










