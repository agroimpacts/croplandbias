---
title: "Calculating cropland biases"
author: "Lyndon Estes"
date: "01 October 2014"
output:
  html_document:
    highlight: tango
    theme: spacelab
    toc: yes
---

## Overview
This section of the analysis calculates the differences between the GTI cropland percentages and those from the various landcover products. It draws from results generated by the [cropland pre-processing](https://github.com/PrincetonUniversity/SAcropland/blob/master/vignettes/sa-cropland-analysis.Rmd). (Note to self here: I want to have a transportable link between chapters here, rather than a direct link to the other RMD document in 
github).

## Analyses
### Sidebar
I am just learning how to use Rmarkdown with Rmd files to document analyses, primarily analyses that are more interactive in nature and notrepeated many times. Code that will be re-used multiple times will go into a library. 

One things I am noticing is that the knit process for compiling the notebook does not find functions within code chunks unless the libraries are called within the code chunks themselves. It seems like each code chunk is its own environment.  The solution to this is to do something like `raster::raster()` when you want a function, or run this where chunks are set to {r, eval = FALSE}, and just run the code chunk as if you were in a normal R script working interactively.  I have already set up the library for SAcropland to call the packages its needs so they are loaded up in the global environment. 

### Load in data 
1. Set up paths
```{r, message = FALSE}
library(lmisc)
library(Hmisc)
library(raster)
library(SAcropland)
p_root <- proj_root("SAcropland")
p_data <- full_path(p_root, "SAcropland/external/ext_data/")
```

2. Load cropland grids 
  + Derived from global landcover products

```{r, message = FALSE}
salc <- raster(full_path(p_data, "sa_ag_masked.tif")) * 100
globsa_list_sum <- lapply(full_path(p_data, dir(p_data, "globSA*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
modsa_list_sum <- lapply(full_path(p_data, dir(p_data, "mod_1*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
glcsa <- raster(full_path(p_data, "glcsa_masked.tif"))
geow <- raster(full_path(p_data, "geowikisa_masked.tif"))
lclist <- c(salc, globsa_list_sum, modsa_list_sum, glcsa, geow)  # into list
names(lclist) <- c("sa30", "globmin", "globmu", "globmax", "modmin", "modmu", "modmax", "glcsh", "geow")
```

  + SA landcover data
```{r, message = FALSE}
load(full_path(p_data, "MZshapes.Rdata"))  
paths <- full_path(p_data, dir(p_data, paste("cover*.*sum_mask*", sep = "")))
gti <- lapply(paths, raster)
```
[[back to top]][Overview]

### Calculate differences at different levels of aggregation
This steps draws on functions I wrote to calculate the actual and absolute differences between a given "master" grid and lists of other grids. This comparison is done at multiple aggregations, ranging from 1-600 km resolution cropland averages. The lists have two levels of nesting, here the upper provides the resolution, the inner provides the different landcover datasets. 

```{r, message = FALSE}
# Mean landcover between 2007 and 2011
gti2 <- c(gti, calc(stack(gti), mean))
names(gti2) <- c("gti2007", "gti2011", "gtimu")

# Aggregate rasters
fact <- c(5, 10, 20, 50, 100, 200)
lc_agg <- aggregate_rast_list(fact, lclist)   # landcover rasters 
gti_agg <- aggregate_rast_list(fact, gti2)  # GTI rasters
```

```{r, eval = FALSE}
# Actual differences
diff_list_act <- lapply(1:length(gti2), function(x) {
  print(paste("processing", x))
  diffr <- diff_rast_list(1:length(lc_agg), subtractor = lc_agg, subtractee = gti_agg, whichdiff = x)
})
names(diff_list_act) <- c("d2007", "d2011", "dmu")  

# Absolute differences
diff_list_abs <- lapply(1:length(gti2), function(x) {
  print(paste("processing", x))
  diffr <- diff_rast_list(1:length(lc_agg), subtractor = lc_agg, subtractee = gti_agg, whichdiff = x, 
                            abs = TRUE)
})
names(diff_list_abs) <- c("d2007", "d2011", "dmu")  
  
# Between 2007 and 2011 GTI
diff_list_gti <- diff_rast_list(1:7, gti_agg, gti_agg, 3)

save(diff_list_act, file = full_path(p_data, "diff_grid_act.rda"))
save(diff_list_abs, file = full_path(p_data, "diff_grid_abs.rda"))
```
[[back to top]][Overview]

14/11/14 - Here I ran into the issue of needing to weight quantiles according to how many pixels went into values in aggregated pixels, otherwise statistics are biased. I explored here different ways of doing this. I am document this here before committing changes so that I can roll this back and look at what I did as needed. I compared original methods statistics with two ways of applying weightings.  

First test method 1. Create a mask for nodata areas, then take aggregated pixels for both the GTI data and the difference grids, disaggregate them, and crop them to the extent of the NA grid. The GTI grid is "cut" into bins, which is less clunky then the previous incarnation.  We then loop through the lists (here I test on just the geowiki differences at 20 km aggregation) by the 2007, 2011, and mean of those two, and extract just the bin I want (now a class), set 0s to NA, multiply by the corresponding difference grid, pooling differences from across all 3 gti version, and then I run box_stats on that. *Note: if I run this on the original aggregated geowiki dataset, without disaggregating, I get the same answer as the final statistics for geowiki at 20 km resolution.*  
```{r, message = FALSE}
load(full_path(p_data, "diff_grid_act.rda"))  # here we'll cheat by loading in the diff grid w/o re-running
namask <- !is.na(gti2$gtimu)
area_wgts <- aggregate(namask, fact = 20, fun = sum)
namask[namask == 0] <- NA

binv <- seq(0, 100, 5)  # cropland bins
rl <- lapply(1:3, function(x) {
  r <- disaggregate(gti_agg$f20[[x]]$geow, fact = 20)
  r <- raster::mask(crop(r, namask), namask)
  rcl <- cut(r, breaks = binv, include.lowest = TRUE)
})

r3l <- lapply(1:3, function(x) {
  r <- disaggregate(diff_list_act[[x]]$f20$geow, fact = 20)
  r <- raster::mask(crop(r, namask), namask)
})

t1 <- do.call(rbind, lapply(1:(length(binv) - 1), function(x) {
  print(x)
  l1 <- unlist(lapply(1:length(rl), function(k) {
    rs <- rl[[k]] == x
    rs[rs == 0] <- NA
    o <- rs * r3l[[k]]
    getValues(o)
  }))
  box_stats(l1)
}))
```

In the next version, I don't do any disaggregation, but I aggregate the NA mask dataset by summing, to get the count of pixels that went into each pixel at each level of aggregation (done in the previous chunk.  This then effectively becomes a weighting raster, which I extract for each aggregated difference.  I then use this as the weights within the Hmisc package.  The result is the same as the first version, but much faster. 
```{r}

p <- c(0.025, 0.25, 0.5, 0.75, 0.975)
rl <- lapply(gti_agg$f20, function(x) cut(x, breaks = binv, include.lowest = TRUE))
r3l <- lapply(1:3, function(x) diff_list_act[[x]]$f20$geow)
t2 <- do.call(rbind, lapply(1:(length(binv) - 1), function(x) {
  print(x)
  l1 <- do.call(rbind, lapply(1:length(rl), function(k) {
    rs <- rl[[k]] == x
    rs[rs == 0] <- NA
    o <- rs * r3l[[k]]
    w <- area_wgts * rs
    oo <- cbind(getValues(o), getValues(w))
  }))
  l12 <- l1[!is.na(l1[, 1]), ]
  if(nrow(l12) > 0) {
    qs <- c(nrow(l12), wtd.quantile(l12[, 1], weights = l12[, 2], probs = p, na.rm = FALSE), 
          wtd.mean(l12[, 1], weights = l12[, 2], na.rm = FALSE))
  } else {
    qs <- rep(NA, 6)
  }
  qs
}))
t2; t1
```

### Bias as function of cropcover
Values from the bias rasters calculated in the previous section are binned by percent cropland cover.  There are a couple of tricky aspects here, related to choosing which cropland map provides the bins. The 2011 GTI mapset more closely corresponds to the MODIS and GLC-SHARE datasets in time, whereas GlobCover and the SA landcover dataset fall closer to or are between the 2007 mapset. __Wayforward__: Calculate whether there is any bias between the 2007 and 2011 cropland estimates by GTI. And also see how much difference exists in bias estimates _as a function of cropcover_ when 2011 GTI provides the bin estimates, and the difference rasters are calculated against different GTI datasets (2007, the mean of 2007 and 2011, and 2011). 

Another complication is the landcover classes to include in the GTI data.  Originally I had the subsistence class added in, but I am now only going to use the no-subsistence set. The no-subsistence set masks out all pixels with >0% subsistence farming coverage. I have also masked out all areas having forestry plantations, which are included in the GLC-SHARE dataset.  

```{r, eval = FALSE}
binv <- seq(0, 100, 5)  # cropland bins

# GTI versus GTI (to measure difference in the different permutations of GTI)
extract_bin_values(gti_agg, "gti2011", diff_list_gti, binv, full_path(p_data, "gti_diff_bin")) 

# Actual landcover differences relative to GTI
nmrt <- c("2007_bin", "2011_bin", "mu_bin")
mind <- c("gti2007", "gti2011", "gtimu")
dind <- c("d2007", "d2011", "dmu")
onm <- paste("act", nmrt, sep = "_")
lapply(1:3, function(x) {
  extract_bin_values(gti_agg, mind[x], diff_list_act[[dind[x]]], binv, full_path(p_data, onm[x]))
})

# Absolute landcover differences
onm <- paste("abs", nmrt, sep = "_")# c("abs_2011_ns_bin", "abs_mu_ns_bin", "abs_2007_ns_bin")
lapply(1:3, function(x) {
  extract_bin_values(gti_agg, mind[x], diff_list_abs[[dind[x]]], binv, full_path(p_data, onm[x]))
})
rm(diff_list_abs, diff_list_act, diff_list_gti)
```
[[back to top]][Overview]

### Calculate biases
#### For GTI data
```{r, eval = FALSE}
load(full_path(p_data, "gti_diff_bin.rda"))
gti_bias <- bin_stats(bin_val_list, fun.list = list(mean), binv)
```

#### For difference rasters
For this, we will have to reshape the difference lists so that we end up with a list that pools biases by cropcover bin across the 3 GTI permutations, but separately for each scale and sensor, before calculating statistics. This is to account for as much uncertainty as possible (e.g. for temporal mismatches between landcover products and GTI). MODIS and GlobCover sets also need to be pooled across the high, medium, and low cover estimates.  
```{r, eval = FALSE}
# Read in and reshape actual differences
nms <- full_path(p_data, paste(paste("act", nmrt, sep = "_"), ".rda", sep = ""))
bin_act <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_act) <- paste("act", nmrt, sep = "_")

fact_all <- c(1, fact)# full aggregation levels
lev_vec <- paste("f", fact_all, sep = "")  
resh <- reshape_diff_list(bin_act, names(lclist), lev_vec, length(binv) - 1)  # reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_act <- c(resh[c("sa30", "glcsh", "geow")], resh_modglob)  # Recombine final reshapes into output list
rm(bin_act)

# Reshape absolute differences
nms <- full_path(p_data, paste(paste("abs", nmrt, sep = "_"), ".rda", sep = ""))
bin_abs <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_abs) <- paste("bs", nmrt, sep = "_")

resh <- reshape_diff_list(bin_abs, names(lclist), lev_vec, length(binv) - 1)  # Reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_abs <- c(resh[c("sa30", "glcsh", "geow")], resh_modglob)  # Recombine final reshapes into output list
rm(resh, resh_modglob, bin_abs)

```

A note: I did checks here to make sure the reshaping was correct, namely by manually pulling out a particular bin from a particular sensor and scale and calculating the mean from that and comparing to the mean from the corresponding part of the reshaped lists. This includes checking the pooled MODIS datasets. 
[[back to top]][Overview]

### Calculate statistics
Now to calculate final statistics per landcover "density" bin (mean, median, 5th, 25th, 75th and 95th percentiles, etc) for each landcover set at each level of aggregation. I am relying on the box_stats function from my lmisc package to generate the necessary statistics for this.

```{r, eval = FALSE}
act_stats <- lapply(resh_out_act, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
abs_stats <- lapply(resh_out_abs, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
```

Save bias statistics and clean up transitional files
```{r, eval = FALSE}
save(gti_bias, act_stats, abs_stats, file = full_path(p_data, "bias_stats.rda"))
for(i in c("act", "abs")) file.remove(full_path(p_data, paste(paste(i, nmrt, sep = "_"), ".rda", sep = "")))
```

## Next steps
Plot bias results.  

[[back to top]][Overview]










