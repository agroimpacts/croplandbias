---
title: "Calculating cropland biases"
author: "Lyndon Estes"
date: "01 October 2014"
output:
  html_document:
    highlight: tango
    theme: spacelab
    toc: yes 
---

## Overview
This section of the analysis calculates the differences between the GTI cropland percentages and those from the various landcover products. It draws from results generated by the [cropland pre-processing](https://github.com/PrincetonUniversity/SAcropland/blob/master/vignettes/sa-cropland-analysis.Rmd). (Note to self here: I want to have a transportable link between chapters here, rather than a direct link to the other RMD document in 
github).

## Analyses
### Sidebar
I am just learning how to use Rmarkdown with Rmd files to document analyses, primarily analyses that are more interactive in nature and notrepeated many times. Code that will be re-used multiple times will go into a library. 

One things I am noticing is that the knit process for compiling the notebook does not find functions within code chunks unless the libraries are called within the code chunks themselves. It seems like each code chunk is its own environment.  The solution to this is to do something like `raster::raster()` when you want a function, or run this where chunks are set to {r, eval = FALSE}, and just run the code chunk as if you were in a normal R script working interactively.  I have already set up the library for SAcropland to call the packages its needs so they are loaded up in the global environment. 

### Load in data 
1. Set up paths
```{r, eval = FALSE}
library(lmisc)
library(raster)
library(SAcropland)
p_root <- proj_root("SAcropland")
p_data <- full_path(p_root, "SAcropland/data/")
```

2. Load cropland grids 
  + Derived from global landcover products

```{r, eval = FALSE}
salc <- raster(full_path(p_data, "salc_ag_masked.tif")) * 100
globsa_list_sum <- lapply(full_path(p_data, dir(p_data, "globSA*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
modsa_list_sum <- lapply(full_path(p_data, dir(p_data, "mod_1*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
glcsa <- raster(full_path(p_data, "glcsa_masked.tif"))
geow <- raster(full_path(p_data, "geowikisa_masked.tif"))
lclist <- c(salc, globsa_list_sum, modsa_list_sum, glcsa, geow)  # into list
names(lclist) <- c("sa30", "globmin", "globmu", "globmax", "modmin", "modmu", "modmax", "glcsh", "geow")
```

  + SA landcover data
```{r, eval = FALSE}
load(full_path(p_data, "MZshapes.Rdata"))  
paths <- full_path(p_data, dir(p_data, paste("cover*.*sum_nh_[subs|stand]*", sep = "")))[c(2, 4, 1, 3)]
gti_nohort <- lapply(paths, raster)
# paths <- full_path(p_data, dir(p_data, paste("cover*.*sum_h_[subs|stand]*", sep = "")))[c(2, 4, 1, 3)]
# gti_hort <- lapply(paths, raster)
```
[[back to top]][Overview]


### Calculate differences at different levels of aggregation
This steps draws on functions I wrote to calculate the actual and absolute differences between a given "master" grid and lists of other grids. This comparison is done at multiple aggregations, ranging from 1-600 km resolution cropland averages. The lists have two levels of nesting, here the upper provides the resolution, the inner provides the different landcover datasets. 
```{r, eval = FALSE}
# Mean landcover between 2007 and 2011
gti_nohort2 <- c(gti_nohort, calc(stack(gti_nohort[1:2]), mean), calc(stack(gti_nohort[3:4]), mean))
names(gti_nohort2) <- c("gti2007", "gti2011", "gti2007_ns", "gti2011_ns", "gtimu", "gtimu_ns")

# Aggregate rasters
fact <- c(5, 10, 20, 50, 100, 200, 300, 600)
lc_agg <- aggregate_rast_list(fact, lclist)   # landcover rasters 
gti_nh_agg <- aggregate_rast_list(fact, gti_nohort2)  # GTI rasters
      
# Actual differences
diff_list_act <- lapply(1:6, function(x) {
  print(paste("processing", x))
  diffr <- diff_rast_list(1:length(lc_agg), subtractor = lc_agg, subtractee = gti_nh_agg, whichdiff = x)
})
names(diff_list_act) <- c("d2007", "d2011", "d2007_ns", "d2011_ns", "dmu", "dmu_ns")  

# Absolute differences
diff_list_abs <- lapply(1:6, function(x) {
  print(paste("processing", x))
  diffr <- diff_rast_list(1:length(lc_agg), subtractor = lc_agg, subtractee = gti_nh_agg, whichdiff = x, 
                            abs = TRUE)
})
names(diff_list_abs) <- c("d2007", "d2011", "d2007_ns", "d2011_ns", "dmu", "dmu_ns")  
  
# Between 2007 and 2011 GTI
diff_list_gti <- diff_rast_list(1:length(gti_nh_agg), gti_nh_agg, gti_nh_agg, 4)

save(diff_list_act, file = full_path(p_data, "diff_grid_act.rda"))
save(diff_list_abs, file = full_path(p_data, "diff_grid_abs.rda"))
```
[[back to top]][Overview]

### Bias as function of cropcover
Values from the bias rasters calculated in the previous section are binned by percent cropland cover.  There are a couple of tricky aspects here, namely related to choosing which cropland map provides the bins. The 2011 GTI mapset more closely corresponds to the MODIS and GLC-SHARE datasets in time, whereas GlobCover and the SA landcover dataset fall closer to or are between the 2007 mapset. __Wayforward__: Calculate whether there is any bias between the 2007 and 2011 cropland estimates by GTI. And also see how much difference exists in bias estimates _as a function of cropcover_ when 2011 GTI provides the bin estimates, and the difference rasters are calculated against different GTI datasets (2007, the mean of 2007 and 2011, and 2011). 

Another complication is the landcover classes to include in the GTI data.  Originally I had the subsistence class added in, but I am now only going to use the no-subsistence set. The no-subsistence set masks out all areas having subsistence class > 10% of coverage in the pixel--why not zero? Because I am mainly trying to get rid of those really large areas where GTI drew a huge polygon around really big communal farmlands.  Including these would cause a cropland over-estimate for those areas). The inclusion of the slight tolerance for this class allows for some misinterpretation error (subsistence field versus non-subsistence field confusion). 

```{r, eval = FALSE}
binv <- seq(0, 100, 5)  # cropland bins

# GTI versus GTI (to measure difference in the different permutations of GTI)
extract_bin_values(gti_nh_agg, "gti2011_ns", diff_list_gti, binv, full_path(p_data, "gti_diff_bin")) 

# Actual landcover differences relative to GTI
nmrt <- c("2011_ns_bin", "mu_ns_bin", "2007_ns_bin")
mind <- c("gti2011_ns", "gtimu_ns", "gti2007_ns")
dind <- c("d2011_ns", "dmu_ns", "d2007_ns")
onm <- paste("act", nmrt, sep = "_")
lapply(1:3, function(x) {
  extract_bin_values(gti_nh_agg, mind[x], diff_list_act[[dind[x]]], binv, full_path(p_data, onm[x]))
})

# Absolute landcover differences
onm <- c("abs_2011_ns_bin", "abs_mu_ns_bin", "abs_2007_ns_bin")
lapply(1:3, function(x) {
  extract_bin_values(gti_nh_agg, mind[x], diff_list_abs[[dind[x]]], binv, full_path(p_data, onm[x]))
})

rm(diff_list_abs, diff_list_act, diff_list_gti)
```
[[back to top]][Overview]

### Calculate biases
#### For GTI data
```{r, eval = FALSE}
load(full_path(p_data, "gti_diff_bin.rda"))
gti_bias <- bin_stats(bin_val_list, fun.list = list(mean), binv)
```

#### For difference rasters
For this, we will have to reshape the difference lists so that we end up with a list that pools biases by cropcover bin across the 3 GTI permutations, but separately for each scale and sensor, before calculating statistics. This is to account for as much uncertainty as possible (e.g. for temporal mismatches between landcover products and GTI). MODIS and GlobCover sets also need to be pooled across the high, medium, and low cover estimates.  
```{r, eval = FALSE}
# Read in and reshape actual differences
nms <- full_path(p_data, paste(paste("act", nmrt, sep = "_"), ".rda", sep = ""))
bin_act <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_act) <- paste("act", nmrt, sep = "_")

fact_all <- c(1, fact)# full aggregation levels
lev_vec <- paste("f", fact_all, sep = "")  
resh <- reshape_diff_list(bin_act, names(lclist), lev_vec, length(binv) - 1)  # reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_act <- c(resh[c("sa30", "glcsh")], resh_modglob)  # Recombine final reshapes into output list

# Reshape absolute differences
nms <- full_path(p_data, paste(paste("abs", nmrt, sep = "_"), ".rda", sep = ""))
bin_abs <- lapply(nms, function(x) {
  load(x)
  bin_val_list
})
names(bin_abs) <- paste("bs", nmrt, sep = "_")

resh <- reshape_diff_list(bin_abs, names(lclist), lev_vec, length(binv) - 1)  # Reshape
resh_modglob <- reshape_reshape_list(resh, c("mod", "glob"), lev_vec, length(binv) - 1)  # pool modis and glob
resh_out_abs <- c(resh[c("sa30", "glcsh")], resh_modglob)  # Recombine final reshapes into output list

save(resh_out_act, file = full_path(p_data, "bin_act_reshape.rda"))
save(resh_out_abs, file = full_path(p_data, "bin_abs_reshape.rda"))

```

A note: I did checks here to make sure the reshaping was correct, namely by manually pulling out a particular bin from a particular sensor and scale and calculating the mean from that and comparing to the mean from the corresponding part of the reshaped lists. This includes checking the pooled MODIS datasets. 
[[back to top]][Overview]

### Calculate statistics
Now to calculate final statistics per landcover "density" bin (mean, median, 5th, 25th, 75th and 95th percentiles, etc) for each landcover set at each level of aggregation. I am relying on the box_stats function from my lmisc package to generate the necessary statistics for this.

```{r, eval = FALSE}
act_stats <- lapply(resh_out_act, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
abs_stats <- lapply(resh_out_abs, function(x) lapply(x, function(y) {
  t(sapply(y, function(z) c("n" = length(z), box_stats(z))))
}))
save(gti_bias, act_stats, abs_stats, file = full_path(p_data, "bias_stats.rda"))

```

## Next steps
From here we will start to plot the results.  

[[back to top]][Overview]










