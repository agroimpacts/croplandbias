% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/landcover-functions.R
\name{rast_list_math}
\alias{rast_list_math}
\title{Apply math on two lists}
\usage{
rast_list_math(ilist, list1, list2, expr, silent = TRUE)
}
\arguments{
\item{ilist}{A 3 element list of list indices (names or index numbers). See details.}

\item{list1}{A two-level list}

\item{list2}{A two-level list}

\item{expr}{A character vector describing the calculation between each list element, e.g. "a - b"}

\item{silent}{TRUE (default) or FALSE, to print (or not) which level of list is being operated on}
}
\description{
Apply arbitrary math to two objects within two lists
}
\details{
This allows aribtrary operations to be performed on lists with two levels. The expression that
is passed to the function requires that "a" reference the element within list1, and "b" the element within
list2 that has the operation applied to it. As written, this performs operations on nested loops (lapply),
with the outer driven by the index in ilist[[1]], the second level driven by ilist[[2]], and the innermost
by ilist[[3]]. The innermost loop performs the operation specified by eval on each list element, where
a = list1[[ilist[[2]]]][[ilist[[3]]]], and b = list2[[ilist[[2]]]][[ilist[[1]]]]. The expression must
therefore always have a and b as its variables. Input lists should be equal on their first dimensions. If
one can understand the complex looping structure, it should be possible to shape lists and indices to use
the function differently
}
\examples{
library(raster)
list1 <- lapply(1:5, function(x) lapply(1:2, function(j) {
  r <- raster(nrow = 10, ncol = 10)
  r[] <- sample(1:20, size = ncell(r), replace = TRUE)
  r
}))
list2 <- lapply(1:5, function(x) lapply(1:6, function(j) {
  r <- raster(nrow = 10, ncol = 10)
  r[] <- sample(1:2, size = ncell(r), replace = TRUE)
  r
}))
o <- rast_list_math(ilist = list(1:6, 1:5, 1:2), list1 = list1, list2 = list2, expr = "a * b",
                    silent = FALSE)
plot(o[[1]][[2]][[1]])
plot(o[[5]][[2]][[1]])
}

