---
title: "Carbon bias"
author: "Lyndon Estes"
date: "June 24, 2015"
output: 
  html_document:
    highlight: tango
    theme: spacelab
    toc: yes 
    number_sections: true
---

# Bias in carbon stock estimates
Based on the Ruesch & Gibbs (2008) approach for estimating carbon density. 

# Data
```{r, eval=FALSE}
library(raster)
library(rgdal)
library(lmisc)
library(data.table)
library(SAcropland)
library(RColorBrewer)
library(xtable)

# Paths
p_root <- proj_root("SAcropland")
p_fig <- full_path(p_root, "SAcropland/paper/figures/")
p_data <- full_path(p_root, "SAcropland/external/ext_data/")
p_data2 <- full_path(p_root, "SAcropland/data/")
p_carb <- full_path(p_root, "SAcropland/external/ext_data/carbon/")
```

## Carbon values

Starting with the carbon look-up tables used for Africa by Ruesch & Gibbs (2008), inputs downloaded from [here](http://cdiac.ornl.gov/epubs/ndp/global_carbon/carbon_documentation.html#methods).
```{r, eval=FALSE}
cfiles <- dir(p_carb, pattern = "m6", full.names = TRUE)
nms <- gsub("*.*m6|\\.txt", "", cfiles)
cval_list <- lapply(1:length(cfiles), function(x) {
  tab <- read.table(cfiles[x])
  tab <- tab[ c(1, 3)]
  colnames(tab) <- c("CL", nms[x])
  tab
})

# merge into single carbon table
mergefun <- function(x, y) merge(x, y, by = "CL", all.x = TRUE, all.y = TRUE)
ctab <- Reduce(mergefun, cval_list)

# Read in lookup table key
key <- readLines(dir(p_carb, pattern = "key", full.names = TRUE))[25:44]
key2 <- readLines(dir(p_carb, pattern = "key", full.names = TRUE))[47:57]
mtch <- sapply(gregexpr("[0-9]", key2), max)
lcs <- sapply(1:length(key2), function(x) substr(key2[x], 1, mtch[x]))
lcs <- gsub(" & ", ",", gsub("-", ":", lcs))

# Reshape and reduce according to carbon classes
ctab2 <- t(data.frame(sapply(lcs, function(x) {
  ind <- eval(parse(text = paste0("c(", x, ")")))
  as.numeric(as.vector(
    round(colMeans(ctab[ctab$CL %in% ind, -1], na.rm = TRUE))))
})))
rownames(ctab2) <- 1:nrow(ctab2)
colnames(ctab2) <- nms
ctab2 <- ctab2 * 0.01  # convert to tons/ha from 1000 kg/ha
ctab2 <- cbind(transform(lcs), ctab2)
colnames(ctab2)[1] <- "class"
```
<a href="#top">Back to top</a>

### Further compress classes that have the same carbon value.

  + 1:3, 6:8 => 1 (broadleaf and mixed forests)
  + 4:5 => Drop
  + 9, 10; 17 => 2 (Secondary forests, forest/cropland mosaic)
  + 11, 12, 15 => 3 (shrublands)
  + 20:23 => drop (water, snow, artificial surfaces)
  + 19 => drop (bare areas)

```{r, eval=FALSE}
ctabf <- round(rbind(colMeans(ctab2[c(1, 3), 2:ncol(ctab2)], na.rm = TRUE), 
                     colMeans(ctab2[10:11, 2:ncol(ctab2)], na.rm = TRUE), 
                     ctab2[4:6, 2:ncol(ctab2)]))

# Read in ecofloristic regions and calculate their areas for Africa
ecoflora <- readOGR("external/ext_data/africa_ecofloristic_zones.sqlite", 
                    layer = "africa_ecofloristic_zones")
ecoflora@proj4string <- CRS("+proj=longlat +datum=WGS84 +no_defs")
afalb <- paste0("+proj=aea +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 ", 
                "+y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
ecoflora_alb <- spTransform(ecoflora, CRS = CRS(afalb))
ecoflora_num <- cbind.data.frame(unique(ecoflora_alb@data),  
                                 "ID" = c("06", "08", "09", "15", "NA", "18",
                                          "20", "16", "17", "WA", "19", "07"),
                                 stringsAsFactors = FALSE)
ecoflora_alb$ID <- rep("NA", nrow(ecoflora_alb))
head(ecoflora_alb)
ecoflora_alb$ID <- ecoflora_num[match(ecoflora_alb$gez_term, 
                                      ecoflora_num$gez_term), "ID"]
# ecoflora_alb@data <- sp::merge(ecoflora_alb@data, ecoflora_num, 
#                                by = "gez_term", sort = FALSE, keep = TRUE)
ecoflora_alb@data[sample(1:nrow(ecoflora_alb@data), 2), ]
ecoflora_alb$area <- round(rgeos::gArea(ecoflora_alb, byid = TRUE) / 1000000, 1)
ecoareas <- sapply(ecoflora_num$ID, function(x) {
  sum(ecoflora_alb@data[ecoflora_alb$ID == x, "area"])
})
ecoareas <- ecoareas[!names(ecoareas) %in% c("WA", "NA")]
ecowgts <- ecoareas / sum(ecoareas)
ecowgts <- ecowgts[sort(names(ecowgts))]

# par(mar = rep(0, 4))
# plot(ecoflora_alb)
# plot(ecoflora_alb[ecoflora_alb$ID == "17", ], col = "red", add = TRUE)

i <- 1:ncol(ctabf)
ctabf$mu <- round(sapply(1:nrow(ctabf), function(x) {
  sum(ctabf[x, ] * ecowgts, na.rm = TRUE)
}), 1)
ctabf <- cbind(ctabf, t(apply(ctabf[, i], 1, function(x) range(x, na.rm=TRUE))))
colnames(ctabf)[(ncol(ctabf) - 1):ncol(ctabf)] <- c("min", "max")
rownames(ctabf) <- 1:nrow(ctabf)
LC <- c("forest", "second", "shrub", "grass", "sparse")
ctabo <- data.frame(t(ctabf[, c("mu", "min", "max")]))  # reclass table
colnames(ctabo) <- LC

```
<a href="#top">Back to top</a>

# Analysis
## Prepare raster data
```{r, eval=FALSE}
load(full_path(p_data, "d_grid_act.rda"))  # actual diffence grids
paths <- full_path(p_data, dir(p_data, paste0("cover*.*11sum_mask.tif$")))
gti <- raster(paths) / 100  # gti 2011
namask <- raster(full_path(p_data, "namask.tif"))  # NA mask
gti <- mask(gti, namask)  # apply mask to GTI
# cellStats(!is.na(gti), sum)

# Reconstruct original landcover estimates
snms <- c("sa30", "globmu", "modmu", "geow")
dlist_1km <- lapply(dlist_act[snms], function(x) x$f1$g2011)
lc_list <- lapply(dlist_1km, function(x) gti - x / 100) 
plot(lc_list[[1]])
# cellStats(!is.na(lc_list[[1]]), sum)
plot(gti)
# tst <- raster("external/ext_data/geowikisa_masked.tif")  # check
# plot(round(tst / 100 - lc_list[[4]], 4)) # okay

# aggregate rasters
fact <- c(5, 10, 25, 50, 100)
lc_agg <- aggregate_rast_list(fact, lc_list)   # landcover rasters 
gti_agg <- aggregate_rast_list(fact, list("gti" = gti))  # GTI rasters

# need NA mask for weighting of aggregated value
# sumna <- function(x) sum(x, na.rm = FALSE)
# namask <- calc(stack(stack(gti), stack(lclist)), sumna)
# namask[namask > 0] <- 1
namask2 <- !is.na(namask)
# namask <- raster(full_path(p_data, "namask.tif")) # load in NA mask
# namask2 <- !is.na(namask)  # set NAs to zero
area_wgts <- aggregate_rast_list(fact, list(namask2), fun = sum)

# cropland cover bins, for looking at error as a function of cover
binv <- seq(0, 1, 0.05)
gti_bins <- lapply(gti_agg, function(x) {
  cut(x$gti, breaks = binv, include.lowest = TRUE)
})

```
<a href="#top">Back to top</a>

## Create cropland carbon estimates
```{r, eval=FALSE}
# Apply carbon estimates
# Function for pixel-wise carbon density from crop & non-crop fractions
carbon <- function(fcrop, cropC, noncropC) {
  carb <- fcrop * cropC + noncropC * (1 - fcrop)
  return(round(carb, 2))
}

cc <- ctab2[ctab2$class == 16, 2]
gti_c <- lapply(gti_agg, function(x) {
  r <- x$gti
  s <- stack(lapply(1:ncol(ctabo), function(y) {
    carbon(r, cc, ctabo[1, y])
  }))
  names(s) <- colnames(ctabo)
  s
})  # gti

lc_c <- lapply(lc_agg, function(x) {
  lc <- lapply(x, function(j) {
    s <- stack(lapply(1:ncol(ctabo), function(y) {
      carbon(j, cc, ctabo[1, y])
    }))
    names(s) <- colnames(ctabo)
    s
  })
  names(lc) <- names(x)
  lc
})  # landcover datasets

# checks--right rasters being referenced? 
tst <- cbind(sample(1:5, 10, replace = TRUE), 
             sample(1:4, 10, replace = TRUE),
             sample(1:5, 10, replace = TRUE))
sapply(1:nrow(tst), function(i) {
  cellStats(lc_c[[tst[i, 1]]][[tst[i, 2]]][[tst[i, 3]]] - 
              carbon(lc_agg[[tst[i, 1]]][[tst[i, 2]]], cc, ctabo[1, tst[i, 3]]),
              sum)
}) # should be all zeroes

```
<a href="#top">Back to top</a>

## Difference the carbon datasets
```{r, eval=FALSE}
# percent difference
pct_diff <- function(x, y) (x - y) / x * 100
c_pct_diff <- lapply(1:length(gti_c), function(x) {
  dif <- lapply(1:length(lc_c[[x]]), function(y) {
    s <- stack(lapply(1:nlayers(lc_c[[x]][[y]]), function(z) {
      p <- pct_diff(gti_c[[x]][[z]], lc_c[[x]][[y]][[z]])
    }))
    names(s) <- colnames(ctabo)
    s
  })
  names(dif) <- names(lc_c[[x]])
  dif
})
names(c_pct_diff) <- names(lc_c)

# checks - right rasters being referenced 
tst <- cbind(sample(1:5, 10, replace = TRUE), 
             sample(1:4, 10, replace = TRUE),
             sample(1:5, 10, replace = TRUE))
sapply(1:nrow(tst), function(i) {
  x <- gti_c[[tst[i, 1]]][[tst[i, 3]]]
  y <- lc_c[[tst[i, 1]]][[tst[i, 2]]][[tst[i, 3]]]
  z <- c_pct_diff[[tst[i, 1]]][[tst[i, 2]]][[tst[i, 3]]]
  cellStats(z - ((x - y) / x * 100), sum)
})  # zeroes

# Then for a map plot figure, calculate the mean pixel-wise percent difference
c_pct_diff_mu <- lapply(c_pct_diff, function(x) {
  lapply(x, function(y) calc(y, mean))
})

# # disggregate selected rasters at selected levels for plotting
# namask <- raster(full_path(p_data, "namask.tif")) # load in NA mask
lev <- names(c_pct_diff_mu) 
disagg <- lapply(snms, function(x) {
  l1 <- lapply(lev, function(y) {
    if(y == "f1") {
      r <- c_pct_diff_mu[[y]][[x]]
    } else {
      r <- raster::disaggregate(c_pct_diff_mu[[y]][[x]], 
                                fact = as.numeric(gsub("f", "", y)))
      r <- raster::mask(crop(r, namask), namask)
    }
  })
  named_out(l1, lev)
})
names(disagg) <- snms

stats <- lapply(disagg, function(x) {
  sapply(x, function(y) {
    c(cellStats(y, mean), quantile(y, seq(0, 1, 0.05)))
  })
})
```
<a href="#top">Back to top</a>

# Outputs
## Carbon bias maps
```{r, eval=FALSE}
load(full_path(p_data, "MZshapes.Rdata"))  # SA shape

# Plotting colors
lims <- c(ceiling(min(sapply(stats, function(x) x[3, ]))), 
          floor(max(sapply(stats, function(x) x[21, ]))))
rng <- range(sapply(stats, range))
brks <- c(rng[1], lims[1], -45, -20, -10, -5, -1, 1, 5, 10, lims[2], rng[2])
#n_cols <- length(brks) - 1
colsall <- brewer.pal(n = 11, "Spectral")
cols <- c(colsall[1:6], "grey80", colsall[c(7, 9, 10, 11)])
#colorRampPalette(c("red", "tan", "grey80"))
#cols2 <- colorRampPalette(c("grey80", "green4", "blue"))
#cols <- c(cols1(8), c(cols2(5)))

# brks <- c(-100.1, -75, -50, -25, -10, 0, 10, 25, 50, 75, 100.1)
# n_cols <- length(brks) - 1
legtext <- "% Difference"
cx <- 1.4
lcol <- "black"
mcap <- c("SA-LC", "GlobCover", "MODIS", "GeoWiki")
lev <- names(disagg[[1]])[-c(2:3)]
lev2 <- c("1 km", "25 km", "50 km", "100 km")
pdf(full_path(p_fig, "carbon_bias_map.pdf"), height = 6, width = 7)
par(mfrow = c(4, 4), mar = c(0, 0, 0, 0), oma = c(5, 5, 2, 0))
for(i in 1:length(snms)) {
  print(snms[i])
  for(j in 1:length(lev)) {
    print(lev[j])
    plot(sa.shp, lty = 0)
    plot(disagg[[snms[i]]][[lev[j]]], add = TRUE, col = cols, 
         breaks = brks, legend = FALSE)
  if(j == 1) mtext(mcap[i], side = 2, line = 1, cex = cx)
  if(i == 1) mtext(lev2[j], side = 3, line = 0, cex = cx)
  }
}
flex_legend(ncuts = length(brks) - 1, legend.text = legtext, 
            legend.vals = round(brks), 
            longdims = c(0.2, 0.8), shortdims = c(0.06, 0.01), 
            colvec = cols, #(length(brks) - 1), 
            srt = c(270, 0), horiz = TRUE, textside = "bottom", 
            legend.pos = c(4, 5), leg.adj = list(c(0.25, 0), c(0, -0.5)), 
            cex.val = cx, textcol = lcol, bordercol = lcol)
dev.off()
```
<a href="#top">Back to top</a>

## Carbon bias statistics
### Calculate how much country-lvel carbon estimates differ between datasets
```{r, eval = FALSE}
lev_vec <- names(c_pct_diff)
# created mask for non-cropland areas, unioning GTI and each LC, filtering out
# areas of no-cropland (<1/2% total cover)
lc_union <- lapply(lev_vec, function(x) {
  lcb <- lapply(snms, function(y) {
    gti_gt0 <- Which(round(gti_agg[[x]]$gti * 100) > 0)
    lc_gt0 <- Which(round(lc_agg[[x]][[y]] * 100) > 0)
    all_gt0 <- gti_gt0 + lc_gt0
    all_gt0[all_gt0 > 0] <- 1
    all_gt0
  })
  named_out(lcb, snms)
})
names(lc_union) <- lev_vec
# plot(lc_union$f50$globmu)
# plot(gti_agg$f50$gti)

# calculate for whole country
tareas <- lapply(area_wgts, function(x) x[[1]] * 100)
gti_ctot <- sapply(1:length(gti_c), function(x) {
  cellStats(gti_c[[x]] * tareas[[x]], sum)
})  # gti total carbon stock
lc_c2 <- lapply(snms, function(x) {
  sapply(names(lc_c), function(y) lc_c[[y]][[x]])
})  # reshape lc_c2 -> landcover in outer list
names(lc_c2) <- snms
lc_ctot <- lapply(lc_c2, function(x) {
  sapply(1:length(x), function(y) {
    cellStats(x[[y]] * tareas[[y]], sum)
  })
})  # landcover total carbon stocks
totc_cntry <- lapply(lc_ctot, function(x) {
  stats <- (gti_ctot - x) / gti_ctot * 100
  colnames(stats) <- names(lc_c2$sa30)
  rownames(stats) <- names(lc_c2$sa30$f1)
  stats
})  # country-level percent differences: gti versus landcover
names(totc_cntry) <- snms

# for cropped areas only - note here we are masking on cropland fraction only,
# not on union of gti and each landcover map, which is needed below for mean 
# bias estimates
tot_area <- sum(freq(namask)[1, 2])  # sum of just the non-NA area
crop_areas <- lapply(lc_union$f1, freq)  
sapply(crop_areas, function(x) x[2, 2] / tot_area)  # 29, 53, 33, 31 

lc_ag2 <- lapply(snms, function(x) {
  sapply(names(lc_agg), function(y) lc_agg[[y]][[x]])
})  # reshape lc_ag2 -> landcover fractions in outer list
gti_ctot2 <- sapply(1:length(gti_c), function(x) {
  msk <- gti_agg[[x]]$gti > 0.005  # farmland > 0.05% mask
  # msk <- gti_agg[[x]]$gti > 0.05  # farmland > 0.05% mask
  msked <- mask(gti_c[[x]] * tareas[[x]], msk, maskvalue = 0)
  cellStats(msked, sum)
})  # gti 
lc_ctot2 <- lapply(1:length(lc_c2), function(x) {
  xx <- lc_c2[[x]]  # recycle reshaped lc_c2 list
  jj <- lc_ag2[[x]]  # recycle reshaped lc_c2 list
  sapply(1:length(xx), function(y) {
    msk <- jj[[y]] > 0.005  # farmland > 0.05% mask
    # msk <- jj[[y]] > 0  # farmland > 0.05% mask
    msked <- mask(xx[[y]] * tareas[[y]], msk, maskvalue = 0)
    cellStats(msked, sum)
  })
})  # landcover carbon estimates

# but discrepancy will only be relevant at 1 km scale, because the carbon total 
# keeps increasing when cropland areas are the only ones being considered
totc_crop <- lapply(lc_ctot2, function(x) {
  stats <- (gti_ctot2 - x) / gti_ctot2 * 100
  colnames(stats) <- names(lc_c2$sa30)
  rownames(stats) <- names(lc_c2$sa30$f1)
  stats
})
names(totc_crop) <- snms

# Combine tables for output to supplementals, 1 km % differences for country
# and agricultural levels
totc_out <- rbind(t(sapply(totc_cntry, function(x) x[, 1])),
                  t(sapply(totc_crop, function(x) x[, 1])))
pnms <- c("Forest", "Secondary", "Shrubland", "Grassland", "Sparse")
knms <- rep(mcap, 2)
totc_out <- cbind.data.frame(knms, round(unname(totc_out), 2))
colnames(totc_out) <- c("Map", pnms)
totc_out <- cbind(Region = c(rep("Country", 4), rep("Agricultural", 4)), 
                  totc_out)
caption <- paste("Percent differences in total carbon stock estimates", 
                 "calculated from the reference maps and from each of the four",
                 "cropland maps. Differences are evaluated for total carbon",
                 "estimates either at the country scale or over just the",
                 "agricultural regions (cropland $>$0.05\\%), using",
                 "the carbon densities of 5 different cover types to provide", 
                 "the values for the non-agricultural portions of each pixel",  
                 "(cover types indicated by column names).")
totc_xtab <- xtable(totc_out, caption = caption, digits = 1)
print(totc_xtab, type = "latex", caption.placement = "top",
      file = "paper/figures/totC-bias.tex", include.rownames = FALSE)

```

### Calculate weighted bias statistics
```{r, eval=FALSE}
# Helper functions to pass into data.table
# not used - switch on if quantiles needs
# bfn <- function(x, y) {
#   box_stats(x, weighted = TRUE, weight.opts = list("weights" = y))
# }
# bfna <- function(x, y) {
#   box_stats(abs(x), weighted = TRUE, weight.opts = list("weights" = y))
# }
wm <- function(x, w) stats::weighted.mean(x, w)
wma <- function(x, w) stats::weighted.mean(abs(x), w)

# check constancy of < 1/2% cropland being excluded
areas <- sapply(lc_agg, function(x) res(x[[1]])[1]^2 / 10000)
plot(areas, (areas * 0.005))  # scales
(areas * 0.005)  # 1/2 to 5000 ha

# selection variables
nms1 <- c(colnames(ctabo), "wgt")
nms2 <- colnames(ctabo)
# bvals <- names(box_stats(sample(1:100, 200, replace = TRUE)))
bvals <- "mu"

dang <- Sys.time()
  #print(paste("..", x))
cb_stats <- lapply(lev_vec, function(x) {  # level
  #x <- lev_vec[4]
  print(paste(".", x))
  #levr <- names(c_pct_diff[[x]])
  l1 <- lapply(names(c_pct_diff[[x]]), function(y) {
    #y <- levr[1]
    print(paste("...", y))
    lc <- c_pct_diff[[x]][[y]]
    lcmask <- lc_union[[x]][[y]]

    # stack raster bins, cropland bins, and landcover set
    s <- stack(list("bin" = gti_bins[[x]], "wgt" = area_wgts[[x]][[1]], 
                    "mask" = lc_union[[x]][[y]], c_pct_diff[[x]][[y]]))
    DT <- na.omit(as.data.table.raster(s))
    setkey(DT, "bin")
    # indexing columns
    #front1 <- data.table("bin" = rep("all", 6), "N" = rep(nrow(DT), 6))
    #front2 <- data.table("bin" = rep("abs", 6), "N" = rep(nrow(DT), 6))
    # stats, overall means
    #m <- cbind(bvals, DT[mask == 1, lapply(.SD, bfn, wgt), .SDcols = nms1])
    #ma <- cbind(bvals, DT[mask == 1, lapply(.SD, bfna, wgt), .SDcols = nms1])
    # stats per bin
    #b <- cbind(bvals, 
    #           DT[mask == 1, lapply(.SD, bfn, wgt), by = bin, .SDcols = nms1])
    #ba <- cbind(bvals, 
    #            DT[mask == 1, lapply(.SD, bfna, wgt), by = bin, .SDcols = nms1])    
    # output
    #odt <- rbind(cbind(front1, mu), cbind(front2, muabs), 
    #             binl[bin][, bin := paste0("a", bin)], 
    #             binl[binabs][, bin := paste0("b", bin)])[, wgt := NULL]

    fr1 <- data.table("bvals" = c("m", "m0", "ma", "ma0"))
    fr2 <- data.table("bin" = "all", "N" = nrow(DT))
    binl <- DT[, .N, by = bin]  # n obs per bin
    a <- round(rbind(DT[mask == 1, lapply(.SD, wm, wgt), .SDcols = nms1], 
                     DT[, lapply(.SD, wm, wgt), .SDcols = nms1], 
                     DT[mask == 1, lapply(.SD, wma, wgt), .SDcols = nms1],
                     DT[, lapply(.SD, wma, wgt), .SDcols = nms1]), 2)
    dtl <- list(DT[mask == 1, lapply(.SD, wm, wgt), by = bin, .SDcols = nms1],
                DT[, lapply(.SD, wm, wgt), by = bin, .SDcols = nms1], 
                DT[mask == 1, lapply(.SD, wma, wgt), by = bin, .SDcols = nms1], 
                DT[, lapply(.SD, wma, wgt), by = bin, .SDcols = nms1])
    b <- rbindlist(lapply(1:4, function(x) cbind(fr1[x], round(dtl[[x]], 2))))
    setkey(b, "bin")
    odt <- rbind(cbind(fr1, rbind(cbind(fr2, a))), binl[b])
  })
  named_out(l1, names(c_pct_diff[[x]]))
})      
dut <- Sys.time() - dang  # 3.65 minutes (vs 33 in earlier incarnation), 
# 24 sec for means only
names(cb_stats) <- lev_vec
#save(cb_stats, file = "external/ext_data/carbon_bias_tables.rda")
save(cb_stats, file = "external/ext_data/carbon_bias_tables_mus.rda")

namevec <- LC
stats <- cb_stats
i1 <- "all"
i2 <- "m"

extract_stat0 <- function(namevec, stats, i1, i2) {
  estats <- do.call(rbind, lapply(namevec, function(i) {
      dat <- sapply(stats, function(x) {
      vals <- unlist(sapply(x, function(y) {
        v <- y[bin == i1 & bvals == i2, i, with = FALSE]
        if(nrow(v) == 0) v <- rbindlist(list(v, as.list(NA)))
        v
      }))
    })#)
  }))
  out <- cbind(do.call(rbind, strsplit(rownames(estats), "\\.")), 
               data.table(round(estats, 2)))
  #setnames(out, old = names(mu), new = "")
  return(out)
}
N <- function(namevec, stats, i1, i2) {
  estats <- data.table(do.call(rbind, lapply(namevec, function(i) {
    o <- sapply(stats, function(x) {
      sapply(x, function(y) y[bin == i1 & bvals == i2, N][1])
    })
  })))
  return(estats)
}
```
<a href="#top">Back to top</a>

### Plot means against scale, supplemental version 
```{r, eval=FALSE}
a <- extract_stat0(LC, cb_stats, "all", "m")  # mean cropland only 
b <- cbind(V2 = "All", a[, lapply(.SD, mean), by = V1, .SDcols = lev_vec])
setcolorder(a, c(2:1, 3:ncol(a)))
mu <- rbind(a, b)

a <- extract_stat0(LC, cb_stats, "all", "ma")  # mean abs cropland only
b <- cbind(V2 = "All", a[, lapply(.SD, mean), by = V1, .SDcols = lev_vec])
setcolorder(b, c(2:1, 3:ncol(b)))
mua <- rbind(a, b)

a <- extract_stat0(LC, cb_stats, "all", "m0")  # mean whole country
b <- cbind(V2 = "All", a[, lapply(.SD, mean), by = V1, .SDcols = lev_vec])
setcolorder(b, c(2:1, 3:ncol(b)))
mu0 <- rbind(a, b)

a <- extract_stat0(LC, cb_stats, "all", "ma0")  # mean abs whole country
b <- cbind(V2 = "All", a[, lapply(.SD, mean), by = V1, .SDcols = lev_vec])
setcolorder(b, c(2:1, 3:ncol(b)))
mu0a <- rbind(a, b)

#yr <- range(all_l[, 3:8, with = FALSE], all_u[, 3:8, with = FALSE])
# yl <- range(all_mus[, 3:8, with = FALSE])

cols <- c("red", "orange3", "green4", "blue")
lcnms <- c("SA LC", "GlobCover", "MODIS", "Geowiki")
pnms <- c("Forest", "Secondary", "Shrubland", "Grassland", "Sparse")
lw <- 1.5

yl <- range(mu[, 3:8, with = FALSE], mua[, 3:8, with = FALSE])
yl <- round(yl / 10) * 10
yax <- seq(yl[1], yl[2], 10)
xax <- seq(1, 6, 5 / (length(yax) - 1))

# Version 1 of mean carbon bias against scale - probably for supplementals, if 
# retained
LC2 <- c(LC, "all")
pdf(full_path(p_fig, "carbon_veg_scale.pdf"), height = 7, width = 5)
par(mfrow = c(3, 2), mar = c(1, 0, 1, 1.25), mgp = c(1, 0.5, 0), tcl = -0.3,  
    oma = c(6, 4, 1, 0))
for(f in 1:length(LC2)) {
  plot(xax, yax, pch = "", yaxt = "n", xaxt = "n", xaxs = "i", yaxs = "i", 
       ylab = "", xlab = "", 
       panel.first = grid(NA, length(yax), lwd = 1, lty = 1))
  #grid(NA, NULL, lwd = 1, lty = 1)
  mtext(side = 3, text = pnms[f], line = 0)
  if(f == 5) axis(1, at = 1:6, labels = c(1, fact))
  if(f %in% c(1, 3, 5)) axis(2, at = yax, labels = yax, las = 2)
  if(f %in% c(2, 4)) axis(2, at = yax, labels = rep("", length(yax)), las = 2)
  for(i in 1:4) {
    lines(1:6, mu[V1 == snms[i] & V2 == LC2[f], lev_vec, with = FALSE], 
          col = cols[i], lty = 2, lwd = lw)
  }
  for(i in 1:4) {
    lines(1:6, mua[V1 == snms[i] & V2 == LC2[f], lev_vec, with = FALSE], 
          col = cols[i], lty = 1, lwd = lw)
  }
}
# plot(xax, yax, pch = "", yaxt = "n", xaxt = "n", xaxs = "i", yaxs = "i", 
#      ylab = "", xlab = "", 
#      panel.first = grid(NA, length(yax), lwd = 1, lty = 1))
# for(i in 1:4) {
#  lines(1:6, mu[V1 == snms[i], lev_vec, with = FALSE], col = cols[i], 
#        lty = 2, lwd = lw)
# }
# for(i in 1:4) {
#   lines(1:6, mua[V1 == snms[i], lev_vec, with = FALSE], col = cols[i],
#         lty = 1, lwd = lw)
# }
mtext(side = 3, text = "Vegetation mean", line = 0)
axis(1, at = 1:6, labels = c(1, fact))
axis(2, at = yax, labels = rep("", length(yax)), las = 2)
mtext(side = 1, text = "Resolution (km)", outer = TRUE, line = 1.5)
mtext(side = 2, text = "Bias/MAE (%)", outer = TRUE, line = 2)
par(xpd = NA)
x <- grconvertX(0.7, from = "ndc", to = "user")
y <- grconvertY(0.075, from = "ndc", to = "user")
legend(x = x, y = y, legend = c("Bias", "MAE"), lty = c(2, 1), 
       lwd = 2, bty = "n", cex = 1.2)
x <- grconvertX(0.1, from = "ndc", to = "user")
y <- grconvertY(0.11, from = "ndc", to = "user")
legend(x = x, y = y, legend = mcap, lty = 1, col = cols, lwd = 2, bty = "n",
       cex = 1.2)
dev.off()

```
<a href="#top">Back to top</a>

### Main text version of mean carbon bias against scale
```{r, eval=FALSE}
alph <- c(225, 40)
#Ccols <- brewer.pal(n = 7, name = "Greys")
LC2 <- c(LC[-grep("second|grass", LC)], "All")
# xax <- seq(0, 7, 6 / (length(yax) - 2)); length(xax)
x <- c(0, 3, 6, 9, 12, 15)
w <- 3 / 8
xo <- (cumsum(rep(w, 8)) - w / 2)[-c(2, 4, 6, 8)]
#x + xo[j] + o[k]
xa <- sapply(x, function(x) x + xo)
mutype <- c("mua", "mu")

o <- c(0, w)
pchs <- c("*", "+", "o", "-")
# cx <- c(1, 0.7, 0.6, 1)
cx <- c(2, 1.25, 1, 1)
g1 <- "grey90"
# pchShow()
# ctabo
xl <- c(-0.5, 18)
yl <- c(-60, 70)
shd <- c(4.5, 10.5, 16.5)

pdf(full_path(p_fig, "carbon_veg_scale.pdf"), height = 7, width = 7)
par(mar = rep(1, 4), oma = c(2, 2, 0, 0), mgp = c(1, 0.5, 0), tcl = -0.3)
plot(xl, yl, pch = "", yaxt = "n", xaxt = "n", xaxs = "i", yaxs = "i", 
     ylab = "", xlab = "")#,
for(i in shd) polyfunc2(x = i, y = yl, w = 3, col = g1, bcol = g1, lwd = 1)
polyfunc2(x = 8.75, y = yl, w = 18.5, col = "transparent", bcol = "black")
grid(NA, 13, lwd = 1, lty = 1)
lines(c(-1, 18), c(0, 0), lwd = 2, col = "grey50")
for(i in 1:length(lev_vec)) {
  for(j in 1:length(snms)) {
    for(k in 1:length(mutype)) {
      dat <- get(mutype[k])[V1 == snms[j] & V2 %in% LC2, get(lev_vec[i])]
      pcol <- makeTransparent(cols[j], alpha = alph[k])
      polyfunc2(xa[j, i] + o[k], range(dat), w = w, col = pcol, bcol = pcol)
      for(z in 1:length(LC2)) {
        lpfunc(x[i] + xo[j] + o[k], dat[z], col = "black", size = cx[z], 
               pch = pchs[z], type = "pt")
      }
    }
  }
}
axis(1, at = seq(1.5, 18.5, 3), labels = c(1, fact))
axis(2, at = yax, labels = yax, las = 2)
mtext(side = 1, text = "Resolution (km)", outer = TRUE, line = 0.5)
mtext(side = 2, text = "Bias/MAE (%)", outer = TRUE, line = 1)
legend(x = 12.4, y = -40, legend = lcnms, pch = 15, col = cols, adj = 0,
       pt.cex = 1.5, bty = "n", cex = 0.8, x.intersp = 0.5)
legend(x = 11.9, y = -40, legend = rep("", 4), pch = 15, adj = 0, 
       col = makeTransparent(cols, alpha = alph[2]), pt.cex = 1.5, bty = "n", 
       cex = 0.8)
text(x = 12.7, y = -42, labels = "MAE", srt = 45, adj = c(0, 0), cex = 0.8)
text(x = 12.2, y = -42, labels = "Bias", srt = 45, adj = c(0, 0), cex = 0.8)
legend(x = 12.1, y = 65, legend = c("Forest", "Shrubland", "Sparse", "Mean"), 
       pch = pchs, pt.cex = c(2, 1.5, 1.5, 2), bty = "n", cex = 0.8)
dev.off()

```
<a href="#top">Back to top</a>

### Supplementary mean bias tables
```{r, eval=FALSE}
# Statistics from non-croplands areas included in means, for supplementals
# mu0[, c(lev_vec) := lapply(.SD, round), .SDcols = lev_vec]
# mu0a[, c(lev_vec) := lapply(.SD, round), .SDcols = lev_vec]
mu0s <- copy(rbind(cbind(Metric = "Bias", mu0), 
                   cbind(Metric = "MAE", mu0a)))
setnames(mu0s, c("V1", "V2", lev_vec), 
         c("Map", "Cover", paste(c(1, fact), "km")))
setkeyv(mu0s, c("Map", "Cover"))
for(i in 1:length(LC)) mu0s[Cover == LC[i], Cover := pnms[i]]
setkey(mu0s, "Map")
for(i in 1:length(snms)) mu0s[Map == snms[i], Map := mcap[i]]

caption <- paste("Biases and mean absolute errors for each of the cropland", 
                 "maps across aggregation scales and each possible landcover", 
                 "type sharing the pixel with cropland. Means were calculated",
                 "across the entire country.")
mu0s_xtab <- xtable(mu0s[order(Metric, Cover)], digits = 1, caption = caption)
print(mu0s_xtab, type = "latex", file = "paper/figures/C-bias-mean-all-SA.tex", 
      tabular.environment = "longtable", floating = FALSE, 
      caption.placement = "top", include.rownames = FALSE)

# Statistics from non-croplands areas included in means, for supplementals
# mu[, c(lev_vec) := lapply(.SD, round), .SDcols = lev_vec]
# mua[, c(lev_vec) := lapply(.SD, round), .SDcols = lev_vec]
mus <- copy(rbind(cbind(Metric = "Bias", mu), 
                  cbind(Metric = "MAE", mua)))
setnames(mus, c("V1", "V2", lev_vec), 
         c("Map", "Cover", paste(c(1, fact), "km")))
setkeyv(mus, c("Map", "Cover"))
for(i in 1:length(LC)) mus[Cover == LC[i], Cover := pnms[i]]
setkey(mus, "Map")
for(i in 1:length(snms)) mus[Map == snms[i], Map := mcap[i]]

caption <- paste("Biases and mean absolute errors for each of the cropland", 
                 "maps across aggregation scales and each possible landcover", 
                 "type sharing the pixel with cropland. Metrics were calculated",
                 "across the union of agricultural areas", 
                 "(cropland $>$0.05\\%) identified by the reference map and", 
                 "the cropland map to which it was being compared")
mus_xtab <- xtable::xtable(mus[order(Metric, Cover)], digits = 1, 
                           caption = caption)
print(mus_xtab, type = "latex", 
      file = "paper/figures/C-bias-mean-cropland-SA.tex", 
      tabular.environment = "longtable", floating = FALSE, 
      caption.placement = "top", include.rownames = FALSE)
```

```{r, eval=FALSE, echo=FALSE}
# Plot means against cropland density (to possibly be run - for now, 
# too much information)
mub <- do.call(rbind, lapply(1:20, function(x) {
  cbind("bin" = x, extract_stat(LC, cb_stats, x, "m"))
}))
muba <- do.call(rbind, lapply(1:20, function(x) {
  cbind("bin" = x, extract_stat(LC, cb_stats, x, "ma"))
}))
n <- do.call(rbind, lapply(1:20, function(x) {
  cbind("bin" = x, N(LC, cb_stats, x, "m"))
}))
#n[, mean(f50), by = bin]

pp <- list("x" = c(-2, 21), "y" = c(0, 0), 
           "x21" = list(c(0, 9), c(9, 21)),
           "y2" = list(c(seq(-100, -10, 10), seq(10, 100, 10)), 
                       seq(10, 100, 10)), 
           "y1lwd" = list(2, 1),  
           "y2lwd" = 0.5, 
           "y2lc" = list(c("black", rep("grey80", 4), "black", rep("grey80", 4),
                           rep("grey80", 4), "black", rep("grey80", 4),"black"),
                         rep("grey80", 10)),
           "yl" = list(c(-100, 100), c(0, 100)), 
           "yl2" = c(-100, 100), "xl" = c(1, 20),
           "xaxl" = unlist(lapply(seq(5, 100, 10), function(x) c(x, " "))),
           "xaxl2" = ifelse(seq(5, 100, 5) %in% c(25, 50, 75), seq(5, 100, 5), 
                            " "),
           "yax1" = list(seq(-100, 100, 50), seq(0, 100, 20)), 
           "ycol" = c("grey70"))  # plot parameters

yax <- seq(-100, 100, 10)
xax <- seq(0, 22, 20 / (length(yax) - 2))

pdf(full_path(p_fig, "carbon_biases_1-100km_v1.pdf"), width = 7.5, height = 7)
par(mfrow = c(6, 4), mar = c(0.5, 0, 0.5, 0.5), mgp = c(1, 0.5, 0), tcl = -0.3,
    oma = c(6, 4, 1, 0))
for(f in 1:length(LC)) {
  for(j in c(1, 4:6)) {#j <- 1; f <- 1
      plot(xax, yax, pch = "", yaxt = "n", xaxt = "n", xaxs = "i", yaxs = "i", 
       ylab = "", xlab = "", 
       panel.first = grid(NA, length(yax) - 1, lwd = 1, lty = 1))
      lines(pp$x, pp$y, lwd = 1)
    for(i in 1:4) {
      mub[V1 == snms[i] & V2 == LC[f], 
          lines(get(lev_vec[j]), col = cols[i], lty = 2, lwd = lw)]
      muba[V1 == snms[i] & V2 == LC[f], 
           lines(get(lev_vec[j]), col = cols[i], lty = 1, lwd = lw)]
    }
  }
}
dev.off()

ys <- c(-100, 100)
yax <- seq(ys[1], ys[2], 10)
xax <- seq(0, 22, 20 / (length(yax) - 2))

#yl <- list(c(-100, 100), c(0, 100))
yl <- seq(yax[1], yax[length(yax)], 10)
yll <- as.character(yl)
yll[seq(2, length(yll) - 1, 2)] <- ""
Ccols <- brewer.pal(n = 6, name = "Dark2") 
xaxl = ifelse(seq(5, 100, 5) %in% c(5, 25, 50, 75, 100), seq(5, 100, 5), " ")
x <- mub[V1 == snms[f] & V2 == LC[j], get(lev_vec[i])]
y <- 100
toohigh <- function(x, y, col = "black", yadj = 0, cex = 1.1) {
  h <- which(abs(x) > abs(y))
  if(length(h) > 0) {
    xi <- h[which.max(h)]
    text(xi, y = y + yadj, labels = round(x[xi]), cex = cex, col = col, 
         xpd = NA)
  }
}

pdf(full_path(p_fig, "carbon_biases_1-100km_v2.pdf"), width = 7.5, height = 7)
par(mfrow = c(4, 4), mar = c(0.5, 0, 0.5, 0.5), mgp = c(1, 0.5, 0), tcl = -0.3,
    oma = c(6, 4, 1, 0))
for(f in 1:length(snms)) {
  for(i in c(1, 4:6)) {#i <- 1; j <- 1; f <- 2
      plot(xax, yax, pch = "", yaxt = "n", xaxt = "n", xaxs = "i", yaxs = "i", 
           ylab = "", xlab = "", 
           panel.first = grid(NA, (length(yax) - 1) / 2, lwd = 1, lty = 1))
      lines(pp$x, pp$y, lwd = 1)
    for(j in 1:length(LC)) {
      e <- parse(text = "V1 == snms[f] & V2 == LC[j]")
      mub[eval(e), 
          lines(get(lev_vec[i]), col = Ccols[j], lty = 2, lwd = lw)]

      mub[V1 == snms[f] & V2 == LC[j], 
          lines(get(lev_vec[i]), col = Ccols[j], lty = 2, lwd = lw)]
      mub[V1 == snms[f] & V2 == LC[j], toohigh(get(lev_vec[i]), ys[1])]
      muba[V1 == snms[f] & V2 == LC[j], 
           lines(get(lev_vec[i]), col = Ccols[j], lty = 1, lwd = lw)]
      axis(1, at = c(1, 5, 10, 15, 20), labels = rep("", 5), mgp = c(1, 1, 0), 
           tcl = -0.7, lwd.ticks = 1.2, pos = pp$yl2[1])
      axis(1, at = 1:20, labels = rep("", 20), las = 2, mgp = c(1, 0.4, 0), 
           tcl = -0.3, pos = pp$yl2[1])
      if(f == length(snms)) {
        axis(1, at = 1:20, labels = pp$xaxl2, las = 2, mgp = c(1, 0.8, 0), 
             tcl = -0.3, pos = pp$yl2[1])
      }
      if(i == 1) axis(2, at = yl, labels = yll, las = 2, mgp = c(1, 0.6, 0))
      if(i == 1 & j == 1) {
        mtext(lcnms[f], side = 2, line = 2.8, cex = 1, col = cols[f])
      }
    }
  }
}
dev.off()

i1 <- "sa30"; i2 <- "forest"; s1 <- "f1"
mub[V1 == i1 & V2 == i2, ]
mub[V1 == i1 & V2 == i2, plot(bin, f1, type = "l")]
mubin[V1 == i1 & V2 == i2, plot(bin, f1, type = "l")]
```

```{r, eval=FALSE, echo=FALSE}
# Checks on data values (embedded code)
# Carbon values and carbon biases - random selection of cells from c_tab_diff
# compared to recalculated values for those points
i <- c_pct_diff
for(chk in list(c("modmu", "f25", "forest"), c("geow", "f10", "shrub"), 
                c("sa30", "f50", "sparse"))) {
  x <- chk[1] #names(i[[1]])[3]
  y <- chk[2] #names(i)[4]
  tp <- chk[3]
  r <- i[[y]][[x]][[tp]]
  rid <- which(values(Which(r != 0)))
  sid <- sample(rid, 20)
  v1 <- r[sid]  # value to check
  sav <- gti_agg[[y]]$gti[sid]
  lcv <- lc_agg[[y]][[x]][sid]
  c1 <- carbon(sav, cropC = 5, noncropC = ctabo[1, tp])
  c2 <- carbon(lcv, cropC = 5, noncropC = ctabo[1, tp])
  #round((sav * 5) + (ctabo[1, tp] * (1 - sav)), 2) == c1
  #round((lcv * 5) + (ctabo[1, tp] * (1 - lcv)), 2) == c2
  print(all(v1 == (c1 - c2) / c1 * 100))
}  # all true
  

# Carbon bias by bins 
# DT-derived values
mu0a <- do.call(rbind, lapply(1:20, function(x) {
  cbind("bin" = x, extract_stat(LC, cb_stats, x, "ma0"))
}))
cb_stats$f1$sa30
cb_stats$f10$sa30[get("bin") == 19, ]

# Older variant of code from compare-landcover.Rmd to evaluate whether newer DT
# version is finding correct results
for(chk in list(c("modmu", "f25", "forest"), c("geow", "f10", "shrub"), 
                c("sa30", "f50", "sparse"))) {
  x <- chk[1] #names(i[[1]])[3]
  y <- chk[2] #names(i)[4]
  tp <- chk[3]
  print(paste(".", x, "..", y, "..", tp))
  d1 <- do.call(rbind, lapply(1:(length(binv) - 1), function(j) {
    #print(paste("......bin", j))
    d2 <- do.call(rbind, lapply(tp, function(z) {#:length(i[[y]][[x]]),..
      #print(paste("........variant", z))
      l3 <- abs(i[[y]][[x]][[z]])  # i[[y]][[x]][[z]]
      #print(paste("........vegetation:", names(l3)))
      d3 <- do.call(rbind, lapply(1, function(k) { #:length(l3)...
        rs <- gti_bins[[y]][[1]] == j #[[k]] == j    
        rs[rs == 0] <- NA
        o <- rs * l3 #[[k]]
        w <- area_wgts[[y]][[1]] * rs
        oo <- cbind.data.frame("lc" = rep(paste0(x, y, z), length(w)), 
                               getValues(o), getValues(w))
      }))
      d3f <- d3[!is.na(d3[, 2]), ]
    }))
    if(nrow(d2) > 0) { #(length(i[[x]][[y]]) * 10)) {
      qs <- c(nrow(d2), box_stats(d2[, 2], weighted = TRUE, 
                                  weight.opts = list("weights" = d2[, 3])))
    } else if((nrow(d2) > 0) & (nrow(d2) < length(i[[x]][[y]]) * 20)) {
      qs <- c(rep(NA, 6), Hmisc::wtd.mean(d2[, 2], weights = d2[, 3], 
                                          na.rm = FALSE))
    } else {
      qs <- rep(NA, 7)
    }
  }))
  #print(round(d1[, "mu"], 2) == mubin[V1 == x & V2 == tp, y, with = FALSE], 
  #          na.rm = TRUE)
  #print(all(round(d1[, "mu"], 2) == mubin[V1 == x & V2 == tp, y, with = FALSE], 
  #          na.rm = TRUE))
  print(all(round(d1[, "mu"], 2) == 
              mu0a[V1 == x & V2 == tp, y, with = FALSE], na.rm = TRUE))
}
# all true

# another check of DT-derived stats against a raster-calculated variant
tst <- sapply(names(c_pct_diff)[1], function(x) {
  lapply(names(c_pct_diff[[1]]), function(y) {
    cellStats(c_pct_diff[[x]][[y]]$forest, mean)
  })
})
mean(round(unlist(tst)), 2) == mean(round(mu0[V2 == "forest", f1]), 2)


gti_gt0 <- Which(gti_agg$f1$gti > 0)
lc_gt0 <- calc(stack(lapply(lc_agg$f1, function(x) Which(x > 0))), sum)
all_gt0 <- gti_gt0 + lc_gt0
all_gt0 <- all_gt0 / all_gt0

filts <- sapply(names(c_pct_diff), function(x) {
  gti_gt0 <- Which(gti_agg[[x]]$gti > 0)
  lc_gt0 <- calc(stack(lapply(lc_agg[[x]], function(j) Which(j > 0))), sum)
  all_gt0 <- gti_gt0 + lc_gt0
  all_gt0 <- all_gt0 / all_gt0
})

tst <- sapply(names(c_pct_diff), function(x) {
  lapply(names(c_pct_diff[[x]]), function(y) {
    cellStats(filts[[x]] * c_pct_diff[[x]][[y]]$forest, mean)
  })
})

tstabs <- sapply(names(c_pct_diff), function(x) {
  lapply(names(c_pct_diff[[x]]), function(y) {
    cellStats(abs(filts[[x]] * c_pct_diff[[x]][[y]]$forest), mean)
  })
})


plot(c(1, 6), range(tst, tstabs), pch = "", xlab = )
for(i in 1:nrow(tst)) lines(1:6, tst[i, ], lty = 2)
for(i in 1:nrow(tstabs)) lines(1:6, tstabs[i, ], col = "red")

cellStats(all_gt0 * c_pct_diff$f1$sa30$sparse, mean)
cellStats(all_gt0 * c_pct_diff$f1$sa30$forest, median)
cellStats(c_pct_diff$f1$sa30$forest, mean)
cellStats(all_gt0 * c_pct_diff$f1$sa30$forest, mean)

```

