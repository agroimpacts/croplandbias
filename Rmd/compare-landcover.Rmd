---
title: "Calculating cropland biases"
author: "Lyndon Estes"
date: "01 October 2014"
output:
  html_document:
    highlight: tango
    theme: spacelab
    toc: yes
---

## Overview
This section of the analysis calculates the differences between the GTI cropland percentages and those from the various landcover products. It draws from results generated by the [cropland pre-processing](https://github.com/PrincetonUniversity/SAcropland/blob/master/vignettes/sa-cropland-analysis.Rmd). (Note to self here: I want to have a transportable link between chapters here, rather than a direct link to the other RMD document in 
github).

## Analyses
### Load in data 
1. Set up paths
```{r, eval = FALSE}
library(lmisc)
library(raster)
library(SAcropland)
p_root <- proj_root("SAcropland")
p_data <- full_path(p_root, "SAcropland/external/ext_data/")
```

2. Load cropland grids 
  + Derived from global landcover products (note: it turns out GLC-Share and geowiki are the same thing)

```{r, eval = FALSE}
salc <- raster(full_path(p_data, "sa_ag_masked.tif")) * 100
globsa_list_sum <- lapply(full_path(p_data, dir(p_data, "globSA*.*1kmrect_sum.tif")[c(2:3, 1)]), raster)
fnames <- full_path(p_data, dir(p_data, "mod_1*.*1kmrect_sum.tif")[c(2:3, 1)])
modsa_list_sum <- lapply(fnames, raster)
glcsa <- raster(full_path(p_data, "glcsa_masked.tif"))
geow <- raster(full_path(p_data, "geowikisa_masked.tif"))
lclist <- c(salc, globsa_list_sum, modsa_list_sum, glcsa, geow)  # into list
names(lclist) <- c("sa30", "globmin", "globmu", "globmax", "modmin", "modmu",
                   "modmax", "glcsh", "geow")
```

  + SA landcover data
```{r, eval = FALSE}
load(full_path(p_data, "MZshapes.Rdata"))  
paths <- full_path(p_data, dir(p_data, paste("cover*.*sum_mask*", sep = "")))
gti <- lapply(paths, raster)
names(gti) <- c("g2007", "g2011")
```
[[back to top]][Overview]

### Calculate differences at different levels of aggregation
This steps draws on functions I wrote to calculate the actual and absolute differences between a given "master" grid and lists of other grids. This comparison is done at multiple aggregations, ranging from 1-600 km resolution cropland averages. The lists have two levels of nesting, here the upper provides the resolution, the inner provides the different landcover datasets. 

```{r, eval = FALSE}
# Aggregate rasters
#fact <- c(5, 10, 25, 50, 100, 200, 300)
#fact <- 25
lc_agg <- aggregate_rast_list(fact, lclist)   # landcover rasters 
gti_agg <- aggregate_rast_list(fact, gti)  # GTI rasters

# Calculate differences
dlist_act <- rast_list_math(list(names(lclist), names(lc_agg), names(gti)),
                            gti_agg, lc_agg, "a - b", silent = FALSE)  # actual
dlist_abs <- rast_list_math(list(names(lclist), names(lc_agg), names(gti)), 
                            gti_agg, lc_agg, "abs(a - b)", silent = FALSE)  # absolute
dlist_gti <- rast_list_math(list("g2007", names(gti_agg), "g2011"), 
                            gti_agg, gti_agg, "a - b", silent = FALSE)

save(dlist_act, file = full_path(p_data, "d_grid_act.rda"))
save(dlist_abs, file = full_path(p_data, "d_grid_abs.rda"))

# Write out the gti cover raster and the actual bias rasters for running impact of bias examples in land
# surface model (25 km resolution)
r <- gti_agg$f25$g2011
projection(r) <- projection(salc)
writeRaster(r, filename = full_path(p_data, "gti_2011_25km.tif"))
b <- brick(stack(lapply(c("sa30", "globmu", "modmu", "geow"), function(x) {
  dlist_act[[x]]$f25$g2011
})))
projection(b) <- projection(salc)
writeRaster(b, filename = full_path(p_data, "lc_bias_25km.tif"))

# r <- raster(full_path(p_data, "gti_2011_25km.tif"))
# lcb <- brick(full_path(p_data, "lc_bias_25km.tif"))
# plot(r - lcb, axes = FALSE, box = FALSE)
# plot(lcb)
# plot(round(lc_agg$f25$geow - (r - lcb$lc_bias_25km.4), 7))

```
[[back to top]][Overview]

### Bias as function of cropcover
+ First create NA mask at 1 km resolution, then weighting raster based on number of non-NA cells in each aggregated pixel, and then "bin" rasters, where each category represents a different cropland fractional cover range (0-5%, 5-10%, etc) 
```{r, eval = FALSE}
# NA mask and weights
namask <- !is.na(gti[[1]])
area_wgts <- aggregate_rast_list(fact, list(namask), fun = sum)
namask[namask == 0] <- NA
writeRaster(namask, filename = full_path(p_data, "namask.tif"), 
            overwrite = TRUE)

# cropland cover bins
binv <- seq(0, 100, 5)
gti_bins <- lapply(gti_agg, function(x) {
  lapply(x, function(y) cut(y, breaks = binv, include.lowest = TRUE))
})
```

+ Calculate biases, pooling MODIS and GlobCover across all version
Step 1. Reshape lists, so that all MODIS and GlobCover variants are pooled by scale
```{r, eval = FALSE}
# Set up indexing parameters
fact_all <- c(1, fact)# full aggregation levels
lev_vec <- paste("f", fact_all, sep = "") 
nm_rt <- c("sa30", "glob", "mod", "glcsh", "geow")

# Reshape the list of actual landcover differences
dlists <- lapply(list(dlist_act, dlist_abs), function(i) {
  resh <- lapply(nm_rt, function(x) {  # select sensor
    l2 <- lapply(lev_vec, function(y) {  # isolate by scale
      l3 <- lapply(i[grep(x, names(i))], function(z) z[[y]])  # sensor by scale
      named_out(l3, names(i)[grep(x, names(i))])
      })
    named_out(l2, lev_vec)
  })
  named_out(resh, nm_rt)
})
names(dlists) <- c("act", "abs")
rm(dlist_act, dlist_abs)  # remove original to make space

```

+ Then calculate biases across datasets
```{r, eval = FALSE}
dang <- Sys.time()
dstats_all <- lapply(dlists, function(i) {
  print("processing 1 of 2 main bias lists")
  dstats <- lapply(names(i), function(x) {
    print(paste("..", x))
    l1 <- lapply(lev_vec, function(y) {
      print(paste("....", y))
      d1 <- do.call(rbind, lapply(1:(length(binv) - 1), function(j) {
        print(paste("......bin", j))
        d2 <- do.call(rbind, lapply(1:length(i[[x]][[y]]), function(z) {
          print(paste("........variant", z))
          l3 <- i[[x]][[y]][[z]]
          d3 <- do.call(rbind, lapply(1:length(l3), function(k) {
            rs <- gti_bins[[y]][[k]] == j    
            rs[rs == 0] <- NA
            o <- rs * l3[[k]]
            w <- area_wgts[[y]][[1]] * rs
            oo <- cbind.data.frame("lc" = rep(names(i)[z], length(w)), 
                                   getValues(o), getValues(w))
          }))
          d3f <- d3[!is.na(d3[, 2]), ]
        }))
        if(nrow(d2) > (length(i[[x]][[y]]) * 10)) {
        qs <- c(nrow(d2), box_stats(d2[, 2], weighted = TRUE, 
                                    weight.opts = list("weights" = d2[, 3])))
        } else if((nrow(d2) > 0) & (nrow(d2) < length(i[[x]][[y]]) * 20)) {
          qs <- c(rep(NA, 6), Hmisc::wtd.mean(d2[, 2], weights = d2[, 3], 
                                              na.rm = FALSE))
        } else {
          qs <- rep(NA, 7)
        }
      }))
      cbind(binv[-1], d1)
      })
    named_out(l1, lev_vec)
  })
  named_out(dstats, names(i))
})
dut <- Sys.time() - dang  # 33 minutes
save(dstats_all, file = full_path(p_data, "bias_stats.rda"))
```
[[back to top]][Overview]

+ Collected absolute differences with weights for regression plots. Test first on 25 km
```{r, eval=FALSE}
gti_2011_25 <- raster(full_path(p_data, "gti_2011_25km.tif"))
snms2 <- c("sa30", "modmu", "globmu", "geow")
km25 <- stack(lapply(dlist_abs[snms2], function(x) x$f25$g2011))
s <- stack(list(area_wgts$f25[[1]], gti_2011_25, km25))
# s <- s[[-10]]
library(agroEcoTradeoffs)
DT <- as.data.table.raster(s)
DT <- DT[!is.na(namask), ]
setnames(DT, "gti_2011_25km", "A")
DTL <- do.call(rbind, lapply(3:ncol(DT), function(x) {
  DTS <- DT[, c(1, 2, x), with = FALSE]
  setnames(DTS, colnames(DT)[x], new = "D")
}))
head(DTL)
DTL[, plot(A, D, pch = 20, cex = 0.1)]
dlm <- lm(D ~ poly(A, degree = 2), weights = namask, data = DTL)
lines(predict.lm(dlm, newdata = data.frame("A" = 1:100)))

DT[, plot(A, geow, pch = 20, cex = 0.1)]
dlm <- lm(geow ~ poly(A, degree = 2), data = DT)
lines(predict.lm(dlm, newdata = data.frame("A" = 1:100)))

```


+ Finally, differences between gti2007 and 2011
```{r, eval = FALSE}
dstats_gti <- lapply(lev_vec, function(x) {
    #x <- lev_vec[[2]]
    i <-  dlist_gti$g2007[[x]][[1]]
    print(paste("..", x))
    d1 <- do.call(rbind, lapply(1:(length(binv) - 1), function(y) {
      #y <- 1
      print(paste("....", y))
      rs <- gti_bins[[x]][[2]] == y    
      rs[rs == 0] <- NA
      o <- rs * i
      w <- area_wgts[[x]][[1]] * rs
      oo <- cbind.data.frame(rep(y, length(w)), getValues(o), getValues(w))
      oof <- oo[!is.na(oo[, 2]), ]
      if(nrow(oof) > 10) {
        qs <- c(nrow(oof), box_stats(oof[, 2], weighted = TRUE, 
                                     weight.opts = list("weights" = oof[, 3])))
      } else if((nrow(oof) > 0) & (nrow(oof) < 10)) {
        qs <- c(rep(NA, 6), 
                Hmisc::wtd.mean(oof[, 2], weights = oof[, 3], na.rm = FALSE))
      } else {
        qs <- rep(NA, 7)
      }
    }))
    cbind(binv[-1], d1)
})
save(dstats_gti, file = full_path(p_data, "bias_stats_gti.rda"))

```
Checks: compared number of non-NA cells coming out of each GTI version at each level of aggregation (fine); compared cell counts between previous committed version and this one (difference exists, but due to fact that gtimu is no longer considered; checked that previous versions of difference rasters and reshapes of them were referencing the correct GTI-landcover bias rasters (i.e. to make sure rasters weren't incorrectly indexed: all fine)); box_stats with weighted quantile option compared to previous commit where wtd.quantile was used separately (fine). Compared results from original roughed out version of approach for calculating bias statistics with results from new outputs list (using geowiki at 20 km aggregation as the comparison)

## Next steps
Plot bias results.  
[[back to top]][Overview]










